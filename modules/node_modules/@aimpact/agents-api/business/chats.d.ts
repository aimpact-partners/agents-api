/************
Processor: ts
************/

import * as __beyond_dep_ns_0 from '@aimpact/agents-api/business/response';
import * as __beyond_dep_ns_1 from '@aimpact/agents-api/data/interfaces';
// chat.ts
declare namespace ns_0 {
  import BusinessResponse = __beyond_dep_ns_0.BusinessResponse;
  import IChatData = __beyond_dep_ns_1.IChatData;
  import IChatDataSpecs = __beyond_dep_ns_1.IChatDataSpecs;
  import IUserBase = __beyond_dep_ns_1.IUserBase;
  import FirestoreService = ns_3.FirestoreService;
  import IMessageSpecs = ns_4.IMessageSpecs;
  export class Chat {
    #private;
    private collection;
    private table;
    firestoreService: FirestoreService;
    constructor();
    static get(id: string, showMessages?: boolean): Promise<BusinessResponse<IChatData>>;
    static save(data: IChatDataSpecs): Promise<BusinessResponse<unknown>>;
    /**
     *
     * @param id
     * @param message
     * @returns
     */
    static saveMessage(ChatId: string, params: IMessageSpecs, user: IUserBase): Promise<BusinessResponse<unknown>>;
    /**
     * saves the chat summary according to the last interaction made
     * assuming an interaction is the message/response pair
     * taking message(role:user)/response(role:system)
     * @param id
     * @param synthesis
     */
    static saveSynthesis(id: string, synthesis: string): Promise<BusinessResponse<unknown>>;
    /**
     * sets the last interaction made in the Chat
     * assuming an interaction is the message/response pair
     * taking message(role:user)/response(role:system)
     * @param id
     * @param limit
     */
    static setLastInteractions(id: string, limit?: number): Promise<BusinessResponse<unknown>>;
    static saveIPE(id: string, ipe: Record<string, any>): Promise<BusinessResponse<unknown>>;
    /**
     * Functions migradas del objeto Chat inicial
     * @TODO validar funcionamiento
     */
    saveAll(items: IChatData[]): Promise<IChatData[]>;
    delete(id: string): Promise<true | {
      status: boolean;
      error: string;
    }>;
    deleteAll(field: string, values?: any | any[]): Promise<any>;
    validate(): boolean;
  }
}


// chats.ts
declare namespace ns_1 {
  import BusinessResponse = __beyond_dep_ns_0.BusinessResponse;
  export class Chats {
    static byUser(id: string): Promise<BusinessResponse<unknown>>;
  }
}


// firestore\delete.ts
declare namespace ns_2 {
  export class BatchDeleter {
    private collectionRef;
    constructor(collectionRef: FirebaseFirestore.CollectionReference);
    deleteAll(property?: string, value?: any | any[]): Promise<any>;
  }
}


// firestore\service.ts
declare namespace ns_3 {
  export class FirestoreService {
    private collectionName;
    constructor(collectionName: string);
    getCollectionRef(): FirebaseFirestore.CollectionReference<FirebaseFirestore.DocumentData, FirebaseFirestore.DocumentData>;
    getDocumentRef(id: string): FirebaseFirestore.DocumentReference<FirebaseFirestore.DocumentData, FirebaseFirestore.DocumentData>;
  }
}


// message.ts
declare namespace ns_4 {
  import IUserBase = __beyond_dep_ns_1.IUserBase;
  import BusinessResponse = __beyond_dep_ns_0.BusinessResponse;
  export interface IMessageSpecs {
    id?: string;
    role: 'system' | 'user' | 'assistant' | 'function';
    content: string;
    answer?: string;
    synthesis?: string;
    timestamp?: number;
    metadata?: any;
  }
  export class Message {
    static publish(chatId: string, params: IMessageSpecs, user: IUserBase): Promise<BusinessResponse<unknown>>;
  }
}


// messages.ts
declare namespace ns_5 {
  export class Messages {
    static getByLimit(chatId: string, limit: number): Promise<{
      id: any;
      content: any;
      chatId: any;
      chat: any;
      role: any;
      timestamp: number;
    }[]>;
  }
}


export import Chat = ns_0.Chat;
export import Chats = ns_1.Chats;

export declare const hmr: {on: (event: string, listener: any) => void, off: (event: string, listener: any) => void };